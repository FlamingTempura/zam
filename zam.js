(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.zam = factory());
}(this, (function () { 'use strict';

const stringify = val => val === null || val === undefined ? '' : String(val);

const arrayRemove = (array, element) => {
	const i = array ? array.indexOf(element) : -1;
	if (i > -1) {
		array.splice(i, 1);
	}
};

// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
const hash = str => str.split('').reduce((hash, char) => (hash << 5) - hash + char.charCodeAt(0) | 0, 0).toString(16);

const nextTick = cb => {
	var cancelled,
	    fn = () => {
		if (!cancelled) {
			cb();
		}
	};
	if (typeof process !== 'undefined') {
		process.nextTick(fn);
	} else {
		let id = String(Math.random()),
		    handler = e => {
			if (e.data === id) {
				e.stopPropagation();
				fn();
				window.removeEventListener('message', handler, true);
			}
		};
		window.addEventListener('message', handler, true);
		window.postMessage(id, '*');
	}
	return () => {
		cancelled = true;
	};
};

var parser = /*
               * Generated by PEG.js 0.10.0.
               *
               * http://pegjs.org/
               */
(function () {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function literal(expectation) {
        return "\"" + literalEscape(expectation.text) + "\"";
      },

      "class": function _class(expectation) {
        var escapedParts = "",
            i;

        for (i = 0; i < expectation.parts.length; i++) {
          escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
        }

        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
      },

      any: function any(expectation) {
        return "any character";
      },

      end: function end(expectation) {
        return "end of input";
      },

      other: function other(expectation) {
        return expectation.description;
      }
    };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
    }

    function classEscape(s) {
      return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
        return '\\x0' + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
        return '\\x' + hex(ch);
      });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i,
          j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},
        peg$startRuleFunctions = { Text: peg$parseText, Expression: peg$parseExpression },
        peg$startRuleFunction = peg$parseText,
        peg$c0 = function peg$c0(parts) {
      return parts.reduce((m, p) => {
        if (typeof p === 'string' && typeof m[m.length - 1] === 'string') {
          m[m.length - 1] += p;
        } else {
          m.push(p);
        }
        return m;
      }, []);
    },
        peg$c1 = function peg$c1(expression) {
      return expression;
    },
        peg$c2 = peg$anyExpectation(),
        peg$c3 = function peg$c3(char) {
      return char;
    },
        peg$c4 = "{{{",
        peg$c5 = peg$literalExpectation("{{{", false),
        peg$c6 = "}}}",
        peg$c7 = peg$literalExpectation("}}}", false),
        peg$c8 = function peg$c8(expression) {
      return { html: true, expression: expression };
    },
        peg$c9 = "{{",
        peg$c10 = peg$literalExpectation("{{", false),
        peg$c11 = "}}",
        peg$c12 = peg$literalExpectation("}}", false),
        peg$c13 = function peg$c13(expression) {
      return { html: false, expression: expression };
    },
        peg$c14 = "=",
        peg$c15 = peg$literalExpectation("=", false),
        peg$c16 = "*=",
        peg$c17 = peg$literalExpectation("*=", false),
        peg$c18 = "/=",
        peg$c19 = peg$literalExpectation("/=", false),
        peg$c20 = "%=",
        peg$c21 = peg$literalExpectation("%=", false),
        peg$c22 = "+=",
        peg$c23 = peg$literalExpectation("+=", false),
        peg$c24 = "-=",
        peg$c25 = peg$literalExpectation("-=", false),
        peg$c26 = function peg$c26(left, operator, right) {
      return { type: "AssignmentExpression", operator: operator, left: left, right: right };
    },
        peg$c27 = "?",
        peg$c28 = peg$literalExpectation("?", false),
        peg$c29 = ":",
        peg$c30 = peg$literalExpectation(":", false),
        peg$c31 = function peg$c31(test, consequent, alternate) {
      return { type: "ConditionalExpression", test: test, consequent: consequent, alternate: alternate };
    },
        peg$c32 = "||",
        peg$c33 = peg$literalExpectation("||", false),
        peg$c34 = function peg$c34(head, arg) {
      return { operator: '||', arg: arg };
    },
        peg$c35 = function peg$c35(head, tail) {
      return buildTree('LogicalExpression', head, tail);
    },
        peg$c36 = "&&",
        peg$c37 = peg$literalExpectation("&&", false),
        peg$c38 = function peg$c38(head, arg) {
      return { operator: '&&', arg: arg };
    },
        peg$c39 = "===",
        peg$c40 = peg$literalExpectation("===", false),
        peg$c41 = "!==",
        peg$c42 = peg$literalExpectation("!==", false),
        peg$c43 = "==",
        peg$c44 = peg$literalExpectation("==", false),
        peg$c45 = "!=",
        peg$c46 = peg$literalExpectation("!=", false),
        peg$c47 = function peg$c47(head, operator, arg) {
      return { operator: operator, arg: arg };
    },
        peg$c48 = function peg$c48(head, tail) {
      return buildTree('BinaryExpression', head, tail);
    },
        peg$c49 = "<=",
        peg$c50 = peg$literalExpectation("<=", false),
        peg$c51 = ">=",
        peg$c52 = peg$literalExpectation(">=", false),
        peg$c53 = "<",
        peg$c54 = peg$literalExpectation("<", false),
        peg$c55 = ">",
        peg$c56 = peg$literalExpectation(">", false),
        peg$c57 = /^[+\-]/,
        peg$c58 = peg$classExpectation(["+", "-"], false, false),
        peg$c59 = /^[*\/%]/,
        peg$c60 = peg$classExpectation(["*", "/", "%"], false, false),
        peg$c61 = "++",
        peg$c62 = peg$literalExpectation("++", false),
        peg$c63 = "--",
        peg$c64 = peg$literalExpectation("--", false),
        peg$c65 = /^[+!\-]/,
        peg$c66 = peg$classExpectation(["+", "!", "-"], false, false),
        peg$c67 = function peg$c67(operator, argument) {
      var type = operator === "++" || operator === "--" ? "UpdateExpression" : "UnaryExpression";
      return { type: type, operator: operator, argument: argument, prefix: true };
    },
        peg$c68 = function peg$c68(argument, operator) {
      return { type: "UpdateExpression", operator: operator, argument: argument, prefix: false };
    },
        peg$c69 = function peg$c69(callee, args) {
      return { type: "CallExpression", callee: callee, arguments: args };
    },
        peg$c70 = function peg$c70(head, tail) {
      return tail.reduce(function (result, property) {
        return { type: "MemberExpression", property: property, object: result };
      }, head);
    },
        peg$c71 = "(",
        peg$c72 = peg$literalExpectation("(", false),
        peg$c73 = ")",
        peg$c74 = peg$literalExpectation(")", false),
        peg$c75 = function peg$c75(head, tail) {
      return tail.reduce(function (result, property) {
        return { type: "MemberExpression", object: result, property: property };
      }, head);
    },
        peg$c76 = "[",
        peg$c77 = peg$literalExpectation("[", false),
        peg$c78 = "]",
        peg$c79 = peg$literalExpectation("]", false),
        peg$c80 = function peg$c80(property) {
      return property;
    },
        peg$c81 = ".",
        peg$c82 = peg$literalExpectation(".", false),
        peg$c83 = function peg$c83(property) {
      return { type: 'Identifier', name: property.name };
    },
        peg$c84 = "new",
        peg$c85 = peg$literalExpectation("new", false),
        peg$c86 = function peg$c86(callee, args) {
      return args;
    },
        peg$c87 = function peg$c87(callee, args) {
      return { type: "NewExpression", callee: callee, arguments: args || [] };
    },
        peg$c88 = function peg$c88() {
      return [];
    },
        peg$c89 = ",",
        peg$c90 = peg$literalExpectation(",", false),
        peg$c91 = function peg$c91(head, arg) {
      return arg;
    },
        peg$c92 = function peg$c92(head, tail) {
      return [head].concat(tail);
    },
        peg$c93 = peg$otherExpectation("identifier"),
        peg$c94 = /^[a-z$_]/i,
        peg$c95 = peg$classExpectation([["a", "z"], "$", "_"], false, true),
        peg$c96 = /^[a-z$_0-9]/i,
        peg$c97 = peg$classExpectation([["a", "z"], "$", "_", ["0", "9"]], false, true),
        peg$c98 = function peg$c98(head, tail) {
      return { type: "Identifier", name: head + tail.join("") };
    },
        peg$c99 = function peg$c99() {
      return { type: "ArrayExpression", elements: [] };
    },
        peg$c100 = function peg$c100(elements) {
      return { type: "ArrayExpression", elements: elements };
    },
        peg$c101 = function peg$c101(head, element) {
      return element;
    },
        peg$c102 = "{",
        peg$c103 = peg$literalExpectation("{", false),
        peg$c104 = "}",
        peg$c105 = peg$literalExpectation("}", false),
        peg$c106 = function peg$c106() {
      return { type: "ObjectExpression", properties: [] };
    },
        peg$c107 = function peg$c107(properties) {
      return { type: "ObjectExpression", properties: properties };
    },
        peg$c108 = function peg$c108(head, pa) {
      return pa;
    },
        peg$c109 = function peg$c109(key, value) {
      return { type: "Property", key: key, value: value };
    },
        peg$c110 = "null",
        peg$c111 = peg$literalExpectation("null", false),
        peg$c112 = function peg$c112() {
      return { type: "Literal", value: null };
    },
        peg$c113 = "true",
        peg$c114 = peg$literalExpectation("true", false),
        peg$c115 = function peg$c115() {
      return { type: "Literal", value: true };
    },
        peg$c116 = "false",
        peg$c117 = peg$literalExpectation("false", false),
        peg$c118 = function peg$c118() {
      return { type: "Literal", value: false };
    },
        peg$c119 = peg$otherExpectation("number"),
        peg$c120 = /^[0-9]/,
        peg$c121 = peg$classExpectation([["0", "9"]], false, false),
        peg$c122 = function peg$c122() {
      return { type: "Literal", value: parseFloat(text()) };
    },
        peg$c123 = "0",
        peg$c124 = peg$literalExpectation("0", false),
        peg$c125 = /^[1-9]/,
        peg$c126 = peg$classExpectation([["1", "9"]], false, false),
        peg$c127 = "e",
        peg$c128 = peg$literalExpectation("e", true),
        peg$c129 = peg$otherExpectation("string"),
        peg$c130 = "\"",
        peg$c131 = peg$literalExpectation("\"", false),
        peg$c132 = "\\\"",
        peg$c133 = peg$literalExpectation("\\\"", false),
        peg$c134 = function peg$c134() {
      return '"';
    },
        peg$c135 = /^[^"]/,
        peg$c136 = peg$classExpectation(["\""], true, false),
        peg$c137 = function peg$c137(chars) {
      return { type: "Literal", value: chars.join("") };
    },
        peg$c138 = "'",
        peg$c139 = peg$literalExpectation("'", false),
        peg$c140 = "\\'",
        peg$c141 = peg$literalExpectation("\\'", false),
        peg$c142 = function peg$c142() {
      return "'";
    },
        peg$c143 = /^[^'']/,
        peg$c144 = peg$classExpectation(["'", "'"], true, false),
        peg$c145 = /^[\t ]/,
        peg$c146 = peg$classExpectation(["\t", " "], false, false),
        peg$currPos = 0,
        peg$savedPos = 0,
        peg$posDetailsCache = [{ line: 1, column: 1 }],
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$resultsCache = {},
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }

    function peg$parseText() {
      var s0, s1, s2;

      var key = peg$currPos * 33 + 0,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseTextCharacter();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseTextCharacter();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTextCharacter() {
      var s0, s1;

      var key = peg$currPos * 33 + 1,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseInlineExpression();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s1);
        }
        s0 = s1;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseInlineExpression() {
      var s0, s1, s2, s3, s4, s5;

      var key = peg$currPos * 33 + 2,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c4) {
        s1 = peg$c4;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c5);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c6) {
                s5 = peg$c6;
                peg$currPos += 3;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c8(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExpression();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c11) {
                  s5 = peg$c11;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c12);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c13(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseExpression() {
      var s0, s1, s2, s3, s4, s5;

      var key = peg$currPos * 33 + 3,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLeftHandSideExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c14;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c15);
            }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c16) {
              s3 = peg$c16;
              peg$currPos += 2;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c18) {
                s3 = peg$c18;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c20) {
                  s3 = peg$c20;
                  peg$currPos += 2;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c21);
                  }
                }
                if (s3 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c22) {
                    s3 = peg$c22;
                    peg$currPos += 2;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c23);
                    }
                  }
                  if (s3 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c24) {
                      s3 = peg$c24;
                      peg$currPos += 2;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c25);
                      }
                    }
                  }
                }
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseConditionalExpression();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLeftHandSideExpression() {
      var s0;

      var key = peg$currPos * 33 + 4,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseCallExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$parseMemberExpression();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseConditionalExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key = peg$currPos * 33 + 5,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLogicalORExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 63) {
            s3 = peg$c27;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseConditionalExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c29;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c30);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseConditionalExpression();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c31(s1, s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLogicalORExpression();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLogicalORExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 6,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLogicalANDExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c32) {
            s5 = peg$c32;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseLogicalANDExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c34(s1, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c32) {
              s5 = peg$c32;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c33);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseLogicalANDExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c34(s1, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLogicalANDExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 7,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseEqualityExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c36) {
            s5 = peg$c36;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseEqualityExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c38(s1, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c36) {
              s5 = peg$c36;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseEqualityExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c38(s1, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEqualityExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 8,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseRelationalExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c39) {
            s5 = peg$c39;
            peg$currPos += 3;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }
          if (s5 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c41) {
              s5 = peg$c41;
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c43) {
                s5 = peg$c43;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c44);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c45) {
                  s5 = peg$c45;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                  }
                }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseRelationalExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c47(s1, s5, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c39) {
              s5 = peg$c39;
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c40);
              }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c41) {
                s5 = peg$c41;
                peg$currPos += 3;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c42);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c43) {
                  s5 = peg$c43;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c44);
                  }
                }
                if (s5 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c45) {
                    s5 = peg$c45;
                    peg$currPos += 2;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c46);
                    }
                  }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRelationalExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c47(s1, s5, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseRelationalExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 9,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseAdditiveExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c49) {
            s5 = peg$c49;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s5 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c51) {
              s5 = peg$c51;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 60) {
                s5 = peg$c53;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c54);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s5 = peg$c55;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c56);
                  }
                }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAdditiveExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c47(s1, s5, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c49) {
              s5 = peg$c49;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c50);
              }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c51) {
                s5 = peg$c51;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c52);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 60) {
                  s5 = peg$c53;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c54);
                  }
                }
                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s5 = peg$c55;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c56);
                    }
                  }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAdditiveExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c47(s1, s5, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseAdditiveExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 10,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (peg$c57.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMultiplicativeExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c47(s1, s5, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (peg$c57.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c58);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMultiplicativeExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c47(s1, s5, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseMultiplicativeExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 11,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (peg$c59.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c60);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseUnaryExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c47(s1, s5, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (peg$c59.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c60);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseUnaryExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c47(s1, s5, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUnaryExpression() {
      var s0, s1, s2, s3;

      var key = peg$currPos * 33 + 12,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsePostfixExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c61) {
          s1 = peg$c61;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c62);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c63) {
            s1 = peg$c63;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c64);
            }
          }
          if (s1 === peg$FAILED) {
            if (peg$c65.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c66);
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseUnaryExpression();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c67(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsePostfixExpression() {
      var s0, s1, s2, s3;

      var key = peg$currPos * 33 + 13,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLeftHandSideExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c61) {
            s3 = peg$c61;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c62);
            }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c63) {
              s3 = peg$c63;
              peg$currPos += 2;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c64);
              }
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c68(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseLeftHandSideExpression();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCallExpression() {
      var s0, s1, s2, s3, s4;

      var key = peg$currPos * 33 + 14,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseMemberExpression();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseArguments();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c69(s2, s4);
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMembershipExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c70(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseMemberExpression() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key = peg$currPos * 33 + 15,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseNewExpression();
      if (s1 === peg$FAILED) {
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$parseLiteral();
          if (s1 === peg$FAILED) {
            s1 = peg$parseArrayLiteral();
            if (s1 === peg$FAILED) {
              s1 = peg$parseObjectLiteral();
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                  s2 = peg$c71;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c72);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseExpression();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parse_();
                      if (s5 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                          s6 = peg$c73;
                          peg$currPos++;
                        } else {
                          s6 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c74);
                          }
                        }
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s1;
                          s2 = peg$c1(s4);
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMembershipExpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c75(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseMembershipExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 16,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$currPos;
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s3 = peg$c76;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseExpression();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s7 = peg$c78;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c79);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c80(s5);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c81;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseIdentifier();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c83(s5);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$currPos;
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s3 = peg$c76;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s7 = peg$c78;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c79);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s2 = peg$c80(s5);
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c81;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c82);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseIdentifier();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c83(s5);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNewExpression() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key = peg$currPos * 33 + 17,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c84) {
        s1 = peg$c84;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c85);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMemberExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseArguments();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s4;
                s5 = peg$c86(s3, s6);
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseArguments() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key = peg$currPos * 33 + 18,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c71;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c72);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c73;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c88();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c71;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExpression();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$currPos;
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c89;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseExpression();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c91(s3, s9);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c89;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c90);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseExpression();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s5;
                        s6 = peg$c91(s3, s9);
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s6 = peg$c73;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c74);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c92(s3, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseIdentifier() {
      var s0, s1, s2, s3, s4;

      var key = peg$currPos * 33 + 19,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseKeywordLiteral();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (peg$c94.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c96.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c97);
            }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c96.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c97);
              }
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c98(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c93);
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseArrayLiteral() {
      var s0, s1, s2, s3, s4, s5;

      var key = peg$currPos * 33 + 20,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c76;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c77);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c78;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c79);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c99();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c76;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseElementList();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c78;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c79);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c100(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseElementList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 21,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c89;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseExpression();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c101(s1, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c89;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseExpression();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c101(s1, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c92(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseObjectLiteral() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 22,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c102;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c103);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s3 = peg$c104;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c105);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c106();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c102;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c103);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsePropertyNameAndValueList();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s6 = peg$c89;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s6 = peg$c104;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c105);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c107(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsePropertyNameAndValueList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key = peg$currPos * 33 + 23,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsePropertyAssignment();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c89;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsePropertyAssignment();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c108(s1, s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c89;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsePropertyAssignment();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c108(s1, s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c92(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsePropertyAssignment() {
      var s0, s1, s2, s3, s4, s5;

      var key = peg$currPos * 33 + 24,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 === peg$FAILED) {
        s1 = peg$parseStringLiteral();
        if (s1 === peg$FAILED) {
          s1 = peg$parseNumericLiteral();
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c29;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c109(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLiteral() {
      var s0;

      var key = peg$currPos * 33 + 25,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseKeywordLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNumericLiteral();
        if (s0 === peg$FAILED) {
          s0 = peg$parseStringLiteral();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseKeywordLiteral() {
      var s0, s1;

      var key = peg$currPos * 33 + 26,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c110) {
        s1 = peg$c110;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c111);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c112();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c113) {
          s1 = peg$c113;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c114);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c116) {
            s1 = peg$c116;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c117);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c118();
          }
          s0 = s1;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNumericLiteral() {
      var s0, s1, s2, s3, s4;

      var key = peg$currPos * 33 + 27,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseDecimalIntegerLiteral();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c81;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c120.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c121);
            }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c120.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c121);
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseExponentPart();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c122();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c81;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c120.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c121);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c120.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c121);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExponentPart();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c122();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDecimalIntegerLiteral();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExponentPart();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c122();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c119);
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDecimalIntegerLiteral() {
      var s0, s1, s2, s3;

      var key = peg$currPos * 33 + 28,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      if (input.charCodeAt(peg$currPos) === 48) {
        s0 = peg$c123;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c124);
        }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (peg$c125.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c120.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c121);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c120.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c121);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseExponentPart() {
      var s0, s1, s2, s3, s4;

      var key = peg$currPos * 33 + 29,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 1).toLowerCase() === peg$c127) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c128);
        }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c57.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c58);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c120.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c121);
            }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c120.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c121);
                }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseStringLiteral() {
      var s0, s1, s2, s3, s4;

      var key = peg$currPos * 33 + 30,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c130;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c131);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c132) {
          s4 = peg$c132;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c133);
          }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c134();
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          if (peg$c135.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c136);
            }
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c132) {
            s4 = peg$c132;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c133);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c134();
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            if (peg$c135.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c136);
              }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c130;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c131);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c137(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c138;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c139);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c140) {
            s4 = peg$c140;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c141);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c142();
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            if (peg$c143.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c144);
              }
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c140) {
              s4 = peg$c140;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c141);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c142();
            }
            s3 = s4;
            if (s3 === peg$FAILED) {
              if (peg$c143.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c144);
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c138;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c139);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c137(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c129);
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parse_() {
      var s0;

      var key = peg$currPos * 33 + 31,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parse__();
      if (s0 === peg$FAILED) {
        s0 = null;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      var key = peg$currPos * 33 + 32,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (peg$c145.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c146);
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c145.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c146);
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    var buildTree = function buildTree(type, head, tail) {
      if (tail.length === 0) {
        return head;
      } else {
        return tail.reduce(function (head, tail) {
          return {
            type: type,
            operator: tail.operator,
            left: head,
            right: tail.arg
          };
        }, head);
      }
    };

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
})();

const parse = function parse(expr) {
	let startRule = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Expression';
	return parser.parse(expr, { startRule });
}; // generates the abstract ast tree

const evaluate = (ast, scope) => {
	let value,
	    set,
	    type = ast.type,
	    operator = ast.operator;

	if (type === 'Literal') {
		value = ast.value;
	} else if (type === 'ArrayExpression') {
		value = ast.elements.map(item => evaluate(item, scope).value);
	} else if (type === 'ObjectExpression') {
		value = Object.assign({}, ...ast.properties.map(p => ({ [p.key.name || p.key.value]: evaluate(p.value, scope).value })));
	} else if (type === 'Identifier') {
		let scope_ = scope;
		while (scope_) {
			if (scope_[ast.name] !== undefined) {
				break;
			}
			scope_ = scope_.$parent; // is data in parent scopes?
		}
		if (!scope_) {
			scope_ = scope;
		} // no? then just use current scope
		value = scope_[ast.name];
		set = val => scope_[ast.name] = val;
	} else if (type === 'MemberExpression') {
		let subject = evaluate(ast.object, scope).value,
		    prop = ast.property.type === 'Identifier' ? ast.property.name : evaluate(ast.property, scope).value;
		value = subject !== undefined ? subject[prop] : undefined;
		set = val => subject[prop] = val;
	} else if (type === 'ConditionalExpression') {
		value = evaluate(ast.test, scope).value ? evaluate(ast.consequent, scope).value : evaluate(ast.alternate, scope).value;
	} else if (type === 'UnaryExpression' || type === 'UpdateExpression') {
		let arg = evaluate(ast.argument, scope),
		    argv = arg.value;
		value = operator === '!' ? !argv : operator === '+' ? +argv : operator === '-' ? -argv : operator === '++' ? argv + 1 : operator === '--' ? argv - 1 : null;
		if (type === 'UpdateExpression') {
			set = arg.set;
			if (set) {
				value = set(value);
			}
			if (!ast.prefix) {
				value += operator === '++' ? -1 : 1;
			}
		}
	} else if (type === 'BinaryExpression' || type === 'LogicalExpression' || type === 'AssignmentExpression') {
		let left = evaluate(ast.left, scope),
		    leftv = left.value,
		    rightv = evaluate(ast.right, scope).value;
		value = operator === '===' ? leftv === rightv : operator === '!==' ? leftv !== rightv : operator === '==' ? leftv == rightv : operator === '!=' ? leftv != rightv : operator === '<' ? leftv < rightv : operator === '>' ? leftv > rightv : operator === '<=' ? leftv <= rightv : operator === '>=' ? leftv >= rightv : operator === '&&' ? leftv && rightv : operator === '||' ? leftv || rightv : operator === '+' ? typeof (leftv + rightv) === 'string' ? stringify(leftv) + stringify(rightv) : leftv + rightv : // avoids undefined + 'a' = 'undefineda'
		operator === '-' ? leftv - rightv : operator === '*' ? leftv * rightv : operator === '/' ? leftv / rightv : operator === '%' ? leftv % rightv : operator === '*=' ? leftv * rightv : operator === '/=' ? leftv / rightv : operator === '%=' ? leftv % rightv : operator === '+=' ? leftv + rightv : operator === '-=' ? leftv - rightv : operator === '=' ? rightv : null;
		if (type === 'AssignmentExpression') {
			set = left.set;
			value = set(value);
		}
	} else if (type === 'CallExpression' || type === 'NewExpression') {
		let caller = ast.callee.object ? evaluate(ast.callee.object, scope).value : scope,
		    callee = evaluate(ast.callee, scope).value,
		    args = ast.arguments.map(arg_ => evaluate(arg_, scope).value);
		value = callee ? type === 'CallExpression' ? callee.apply(caller, args) : new (callee.bind.apply(callee, args))() : undefined;
	}

	return { value, set };
};

var version = "0.5.0";

var config = {
	prefix: 'z-',
	directives: [],
	inlineParser: undefined
};

const cloneAttribute = attr => ({ name: attr.name, value: attr.value });

const execBinds = (vnode, method, scope) => {
	vnode.binds.forEach(bind => execBind(vnode, method, bind));
	vnode.children.forEach(vnode => vnode[method + 'Binds'](scope));
};

const execBind = (vnode, method, bind) => {
	if (!bind.directive[method]) {
		return;
	}
	if (method === 'initialize') {
		bind.directive[method].call(bind, vnode.node, ...bind.args);
	} else {
		bind.directive[method].call(bind, vnode.scope, vnode.node, ...bind.args);
	}
};

const createVNode = (node, source, override) => {
	if (node instanceof VirtualNode) {
		return node;
	} else if (typeof node === 'string') {
		// selector
		node = document.querySelector(node);
	} else if (node.jquery) {
		// jquery element
		node = node[0];
	}
	return new VirtualNode(node, source, override);
};

let id$1 = 0;

class VirtualNode {
	constructor(node, source) {
		let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		this.__id = ++id$1;
		this.node = node;
		this.children = [];
		this.binds = [];
		this.type = node.nodeType;

		if (node.vnode && !source) {
			//log('vnode.create - already a vnode for this node');
			if (override) {
				this.parent = node.vnode;
				node.vnode = this;
				this.type = this.parent.type;
				this.children = this.parent.children;
				this.binds = this.parent.binds;
				this.parent.children = [];
				this.parent.binds = [];
			} else {
				//log('vnode.create - make pointer');
				node.vnode.parent = this;
				this.pointer = node.vnode;
			}
		} else if (source) {
			node.vnode = this;
			this.blocked = source.blocked;
			this.type = source.type;
			source.binds.forEach((_ref) => {
				let directive = _ref.directive,
				    args = _ref.args;

				//this.bind({ ast: bind.ast, directive: bind.directive, args: bind.args, key: bind.key, template: bind.template });
				this.bindDirective(directive, ...args);
			});
			if (source.attributes) {
				this.attributes = source.attributes.map(cloneAttribute);
				this.removedAttrs = source.removedAttrs.map(cloneAttribute);
			}
			let childNodes = Array.from(node.childNodes).filter(cnode => cnode.nodeType === 1 || cnode.nodeType === 3);
			source.children.forEach(vnode => {
				this.children.push(createVNode(vnode.fragment ? node : childNodes.shift(), vnode));
			});
		} else {
			node.vnode = this;
			this.initialize();
		}
	}
	initialize() {
		let node = this.node;
		this.type = node.nodeType; // 1 = ELEMENT_NODE, 3 = TEXT_NODE
		//log('vnode.init', this.outerHTML, node.nodeValue, this.type, node.nodeType);
		if (this.type === 1) {
			this.tag = node.tagName;
			this.attributes = Array.from(node.attributes).map(cloneAttribute);
			this.removedAttrs = [];
			config.directives.forEach(directive => {
				let tagMatch = this.tag.match(new RegExp(`^${directive.tagQuery.replace('{prefix}', config.prefix)}$`, 'i')),
				    isMatch = tagMatch;
				while (isMatch) {
					// multiple instances of a directive can used on an element
					if (this.blocked) {
						break;
					}

					let attrMatches = directive.attributeQueries.map(attrQ => {
						if (!isMatch) {
							return;
						}
						let match;
						this.attributes.find(attr => {
							match = attr.name.match(new RegExp(`^${attrQ.name.replace('{prefix}', config.prefix)}$`, 'i'));
							return match;
						});
						if (match) {
							return { name: match[0], match: match.slice(1) };
						} else if (attrQ.defaultValue) {
							return { name: attrQ.name, ast: attrQ.defaultValue, default: true };
						}
						isMatch = false;
					});

					if (!isMatch) {
						break;
					}

					let tag = { name: tagMatch[0], match: tagMatch.slice(1) },
					    attributes = attrMatches.map(match => {
						if (!match.default) {
							let attr = this.attributes.find(attr => attr.name === match.name);
							match.ast = parse(attr.value || 'undefined');
							this.attributes.splice(this.attributes.indexOf(attr), 1);
							this.removedAttrs.push(cloneAttribute(attr));
							node.removeAttribute(match.name);
						}
						return match;
					});

					this.bindDirective(directive, tag, ...attributes);

					if (attrMatches.length === 0) {
						break;
					} // do not allow the tag to be matched alone again (prevents infinite loops)
				}
			});

			if (!this.blocked && node.childNodes) {
				Array.from(node.childNodes).filter(node => node.nodeType === 1 || node.nodeType === 3).map(node => this.children.push(createVNode(node)));
			}
		} else if (this.type === 3 && node.nodeValue.includes('{{')) {
			let parts = parse(node.nodeValue, 'Text');
			if (parts.length === 1) {
				if (typeof parts[0] !== 'string') {
					if (parts[0].html) {
						let oldNode = node;
						node = this.node = document.createElement('span');
						oldNode.parentNode.replaceChild(node, oldNode);
					} else {
						node.textContent = '';
					}
					this.bindDirective(config.inlineParser, null, {
						match: [parts[0].html ? 'html' : 'text'],
						ast: parts[0].expression
					});
				}
			} else {
				let fragment = document.createDocumentFragment();
				this.fragment = true;
				parts.forEach(part => {
					let newNode = typeof part === 'string' ? document.createTextNode(part) : part.html ? document.createElement('span') : document.createTextNode(''),
					    newVNode = createVNode(newNode);
					if (typeof part !== 'string') {
						newVNode.bindDirective(config.inlineParser, null, {
							match: [part.html ? 'html' : 'text'],
							ast: part.expression
						});
					}
					fragment.appendChild(newNode);
					this.children.push(newVNode);
				});
				node.parentNode.replaceChild(fragment, node);
			}
		}
	}
	bindDirective(directive) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		args = args.map(arg => {
			arg = Object.assign({}, arg);
			arg.value = () => evaluate(arg.ast, this.scope).value;
			return arg;
		});
		let binding = { directive, args };
		if (directive.block) {
			this.blocked = true; // stop looking for more attributes
		}
		if (directive.template) {
			let vnode = directive.template.clone();
			//node_.vnode = this;
			Array.from(this.node.attributes).map(attr => {
				vnode.node.setAttribute(attr.name, attr.value); // copy over attributes
			});

			this.node.parentNode.replaceChild(vnode.node, this.node);
			this.node = vnode.node;
			this.node.vnode = this;
			this.binds = this.binds.concat(vnode.binds);
			this.type = vnode.type;
			this.children = vnode.children;
			//this.node = node_;
			//this.pointer = node_;
			//this.initialize();
		} else {
			this.binds.push(binding);
		}
		execBind(this, 'initialize', binding);
	}
	clone() {
		return createVNode(this.node.cloneNode(true), this);
	}
	createBinds(scope) {
		this.scope = scope;
		execBinds(this, 'create', scope);
		//if (this.pointer) { this.pointer.createBinds(scope); }
	}
	updateBinds() {
		execBinds(this, 'update');
		if (this.pointer) {
			this.pointer.updateBinds();
		}
	}
	destroyBinds() {
		execBinds(this, 'destroy');
		if (this.removedAttrs) {
			this.removedAttrs.forEach(attr => this.node.setAttribute(attr.name, attr.value)); // restore attributes
		}
	}
	__print() {
		let indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

		console.log(`@${indent}> [${this.__id}] ${this.node.outerHTML || this.node.textContent}`);
		this.children.forEach(child => child.__print(`--${indent}`));
	}
}

let createDirective = directive => {
	let parts = directive.query.match(/<([^\s>="]+)((?:\s+[^\s>="]+(?:\s*=\s*"[^"]*")?)*)>/);

	directive.tagQuery = parts[1];
	directive.attributeQueries = [];

	parts[2].replace(/\s+([^\s>="]+)(?:\s*=\s*"([^"]*)")?/g, (m, name, defaultValue) => {
		if (defaultValue !== undefined) {
			defaultValue = parse(defaultValue || 'undefined');
		}
		directive.attributeQueries.push({ name, defaultValue });
	});

	if (directive.inline) {
		config.inlineParser = directive;
	}
	if (directive.template) {
		directive.block = true;
		var node = document.createElement('span');
		node.innerHTML = directive.template;
		if (node.childNodes.length === 1) {
			node = node.childNodes[0];
		}
		directive.template = createVNode(node);
	}
	if (!directive.order) {
		directive.order = 100;
	}
	let i = config.directives.findIndex(directive_ => directive.order < directive_.order); // insert in order of priority
	config.directives.splice(i === -1 ? config.directives.length : i, 0, directive);
	return directive;
};

let id = 0;
let preparingProxy;

const emit = (events, event) => {
	if (events[event]) {
		events[event].forEach(cb => cb());
	}
};

const deepProxy = function deepProxy(view, obj) {
	let parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	// when something in the scope changes, update the view
	if (parents.includes(obj)) {
		return;
	} // prevent circular recursion
	parents = parents.concat([obj]);
	return new Proxy(obj, {
		get(target, prop, receiver) {
			var q = Reflect.get(target, prop, receiver);
			if (target instanceof Date && typeof prop === 'string') {
				if (prop.startsWith('set')) {
					// some properties are Symbols, not strings
					view.$(true);
				}
				return q.bind(target);
			}
			return !(target instanceof Array) && typeof q === 'function' ? q.bind(target) : q; // binding target ensures things like Date.getDate work
		},
		set(target, prop, value, receiver) {
			if (!preparingProxy) {
				if (typeof value === 'object' && value !== null) {
					value = deepProxy(view, value, parents);
				}
				view.$(true);
			}
			preparingProxy = true; // prevents triggering parent views which also proxy this object
			let a = Reflect.set(target, prop, value, receiver);
			preparingProxy = false;
			return a;
		},
		deleteProperty(target, prop) {
			if (!preparingProxy) {
				view.$(true);
			}
			preparingProxy = true; // prevents triggering parent views which also proxy this object
			let a = Reflect.deleteProperty(target, prop);
			preparingProxy = false;
			return a;
		}
	});
};

const zam$1 = (el, data, parent) => {
	//log('view#' + id + '.create');
	let vnode = createVNode(el, null, true),
	    events = {},
	    watchers = [],
	    deferringUpdate,
	    view = Object.assign({
		$id: id++,
		$(defer) {
			// update binds. use defer to wait until end of execution cycle (these will be collapsed into one update)
			if (!vnode) {
				return;
			}
			if (!defer) {
				if (deferringUpdate) {
					deferringUpdate = deferringUpdate();
				} // cancel
				//log('view#' + view.$id + '.update');
				vnode.updateBinds(view);
				emit(events, 'update');
				watchers.forEach(watcher => {
					const val = evaluate(watcher.ast, view).value;
					if (val !== watcher.val) {
						watcher.val = val;
						watcher.cb(val);
					}
				});
			} else if (!deferringUpdate) {
				deferringUpdate = nextTick(() => view.$());
			}
			return view;
		},
		$destroy() {
			vnode.destroyBinds(view);
			emit(events, 'destroy');
			vnode = undefined;
			return view;
		},
		$on(event, cb) {
			events[event] = [cb].concat(events[event] || []);
			return view;
		},
		$off(event, cb) {
			arrayRemove(events[event], cb);
			return view;
		},
		$watch(expr, cb) {
			watchers.push({ expr, ast: parse(expr), cb });
			return view;
		},
		$unwatch(expr, cb) {
			const watcher = watchers.find(w => w.expr === expr && w.cb === cb);
			arrayRemove(watchers, watcher);
			return view;
		},
		get $parent() {
			return parent || vnode.parent && vnode.parent.scope || zam$1.root;
		},
		__print() {
			vnode.__print();
		}
	}, data);

	vnode.createBinds(view);
	view.$(true);
	return deepProxy(view, view);
};

Object.assign(zam$1, {
	version, parse, evaluate,
	directive: createDirective,
	root: {
		$parent: typeof global !== 'undefined' ? global : window,
		number: function number(num) {
			let dec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
			return Number(num).toFixed(dec);
		},
		percent: function percent(num) {
			let dec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
			return `${Number(num * 100).toFixed(dec)}%`;
		}
	}
});
Object.defineProperty(zam$1, 'prefix', {
	get() {
		return config.prefix;
	},
	set(prefix) {
		config.prefix = prefix;
	}
});

/*
`z-text` and `z-html` - Set text or HTML content
@ORDER 1

Sets the text or HTML content of the specified element. Text and HTML can also
be set using template tags (`{{ blah }}`). When setting HTML, it will not be
checked for directives, and be aware of the risks of
[XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) when using user-
entered content.

@CODE
My name is <div>{{ me.name }}</div>
My name is <div z-text="me.name"></div><!-- equivalent to above -->
Some HTML: <span>{{{ boldName }}}</span>
Some HTML: <span z-html="boldName"></span>
Together: <span>{{ me.name }}, {{{ boldName }}}</span>
<script>
	const view = zam(document.body);
	view.me = { name: 'Bob' };
	view.boldName = '<em>Bob</em>';
</script>
@RESULT
*/
var dText = {
	query: '<.+ {prefix}(text|html)>',
	block: true,
	inline: true,
	initialize(el) {
		el.innerHTML = '';
	},
	update(scope, el, tag, attr) {
		let value = stringify(attr.value());
		if (value !== this.value) {
			if (attr.match[0] === 'html') {
				el.innerHTML = value;
			} else {
				el.textContent = value;
			}
			this.value = value;
		}
	}
};

/*
`z-show` - Conditional visibility
@ORDER 2

Displays the element only if the result of the expression is
[truthy](https://developer.mozilla.org/en/docs/Glossary/Truthy) (e.g. true,
1). Equivalent to `z-attr-display="thing ? '' : 'none'"`.

@CODE
<div z-show="showMe">My name is {{ me.name }}</div>
<button z-on-click="hide()">Hide</button>
<script>
	const view = zam(document.body);
	view.me = { name: 'Bob' };
	view.showMe = true;
	view.hide = () => {
		view.showMe = false;
	};
</script>
@RESULT
*/
var dShow = {
	query: '<.+ {prefix}show>',
	update(scope, el, tag, attr) {
		let value = attr.value() ? '' : 'none';
		if (value !== this.value) {
			el.style.display = this.value = value;
		}
	}
};

/*
`z-attr-*` - Attribute value
@ORDER 5

Sets the value of an element's attribute. As a shorthand, `attr-` may be
omitted for standard HTML attributes, like `disabled`, `src`, and `alt`.

@CODE
<img z-attr-src="pic">
<img z-src="pic"><!-- you can omit 'attr-' for standard HTML attributes -->
<input z-disabled="!showMe"></input>
<button z-disabled="showMe"></button>
<script>
	const view = zam(document.body);
	view.showMe = false;
	view.pic = 'photo.png';
</script>
@RESULT
*/
const standardAttributes = ['accept', 'accept-charset', 'accesskey', 'action', 'align', 'alt', 'async', 'autocomplete', 'autofocus', 'autoplay', 'autosave', 'buffered', 'challenge', 'charset', 'checked', 'cite', 'class', 'code', 'codebase', 'cols', 'colspan', 'content', 'contenteditable', 'contextmenu', 'controls', 'coords', 'crossorigin', 'data', 'data-*', 'datetime', 'default', 'defer', 'dir', 'dirname', 'disabled', 'download', 'draggable', 'dropzone', 'enctype', 'for', 'form', 'formaction', 'headers', 'hidden', 'high', 'href', 'hreflang', 'http-equiv', 'icon', 'id', 'integrity', 'ismap', 'itemprop', 'keytype', 'kind', 'label', 'lang', 'language', 'list', 'loop', 'low', 'manifest', 'max', 'maxlength', 'minlength', 'media', 'method', 'min', 'multiple', 'muted', 'name', 'novalidate', 'open', 'optimum', 'pattern', 'ping', 'placeholder', 'poster', 'preload', 'radiogroup', 'readonly', 'rel', 'required', 'reversed', 'rows', 'rowspan', 'sandbox', 'scope', 'scoped', 'seamless', 'selected', 'shape', 'size', 'sizes', 'slot', 'span', 'spellcheck', 'src', 'srcdoc', 'srclang', 'srcset', 'start', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'value', 'wrap'];

const booleanAttributes = ['selected', 'checked', 'disabled', 'readonly', 'multiple', 'ismap', 'defer', 'noresize'];

var dAttr = {
	query: `<.+ {prefix}(attr-.+|${standardAttributes.join('|')})>`,
	initialize(el, tag, attr) {
		this.attrName = attr.match[0].replace(/^attr-/, '');
	},
	update(scope, el, tag, attr) {
		let value = attr.value();
		if (value !== this.value) {
			this.value = value;
			if (booleanAttributes.includes(this.attrName)) {
				value = value ? this.attrName : undefined;
			}
			if (value === undefined) {
				el.removeAttribute(this.attrName);
			} else {
				el.setAttribute(this.attrName, stringify(value));
			}
		}
	}
};

/*
`z-class-*` - Conditional class name
@ORDER 6

Adds the specified classname only if the result of the expression is
[truthy](https://developer.mozilla.org/en/docs/Glossary/Truthy) (e.g. true,
1).

@CODE
<h4 z-class-red="warning" z-class-green="!warning"></h4>
<script>
	const view = zam(document.body);
	view.warning = true;
</script>
@RESULT
*/
var dClass = {
	query: '<.+ {prefix}class-(.+)>',
	update(scope, el, tag, clas) {
		let value = clas.value();
		if (value !== this.value) {
			this.value = value;
			el.classList.toggle(clas.match[0], value);
		}
	}
};

/*
`z-exist` - Conditional existence
@ORDER 3

Renders the element only if the result of the expression is
[truthy](https://developer.mozilla.org/en/docs/Glossary/Truthy) (e.g. true,
1). Unlike z-show, the directives inside the element will not be updated while
the element is hidden (since the element is in fact destroyed when falsey and
recreated when truthy). This directive occurs after `z-in` and before anything
else.

Note: this is equivalent to `ng-if` in angular.

@CODE
<div z-exist="showMe">My name is {{ me.name }}</div>
<div z-exist="!showMe">I'm not here</div>
<button z-click="hide()">Hide</button>
<script>
	const view = zam(document.body);
	view.me = { name: 'Bob' };
	view.showMe = true;
	view.hide = () => {
		view.showMe = false;
	};
</script>
@RESULT
*/
var dExist = {
	query: '<.+ {prefix}exist>',
	order: 3,
	block: true, // stop traversal into the element if it should not exist
	initialize(el) {
		// dom manipulation shouldn't happen in init as it will interfere with the virtualdom
		this.template = createVNode(el.cloneNode(true)); // clone needed (for pointer)
	},
	create(scope, el, tag, attr) {
		this.marker = document.createComment(attr.name);
		el.parentNode.replaceChild(this.marker, el);
	},
	update(scope, el, tag, attr) {
		let value = !!attr.value();
		if (value !== this.value) {
			if (value) {
				this.vnode = this.template.clone();
				this.marker.parentNode.insertBefore(this.vnode.node, this.marker);
				this.view = zam$1(this.vnode, undefined, scope).$();
			} else if (this.view) {
				this.view.$destroy();
				this.marker.parentNode.removeChild(this.vnode.node);
				delete this.vnode;
				delete this.view;
			}
			this.value = value;
		}
	}
};

/*
`z-style-*` - Style value
@ORDER 7

Sets the value of the specified CSS property of the element. As a shorthand,
`style-` may be omitted for standard CSS properties, such as `border`, `top`,
and `width`.

@CODE
<h1 z-style-font-weight="big ? 'bold' : 'normal'"></h1>
<em z-font-weight="big ? 'bold' : 'normal'"></em><!-- equivalent to above -->
<p z-color="color" z-font-size="fontsize + 'pt'"></p> 
<script>
	const view = zam(document.body);
	view.big = true;
	view.color = 'red';
	view.fontsize = 12
</script>
@RESULT
*/
const standardStyles = ['align-.*', 'all', 'animation', 'animation-.*', 'backface-visibility', 'background', 'background-.*', 'border', 'border-.*', 'bottom', 'box-.*', 'break-.*', 'caption-side', 'caret-color', 'clear', 'clip', 'clip-path', 'color', 'column-.*', 'columns', 'content', 'counter-.*', 'cursor', 'direction', 'display', 'empty-cells', 'filter', 'flex-.*', 'float', 'font', 'font-.*', 'grid', 'grid-.*', 'height', 'hyphens', 'image-.*', 'ime-mode', 'inline-size', 'isolation', 'justify-content', 'left', 'letter-spacing', 'line-.*', 'list-.*', 'margin', 'margin-.*', 'mask', 'mask-.*', 'max-height', 'max-width', 'min-block-size', 'min-height', 'min-inline-size', 'min-width', 'mix-blend-mode', 'object-fit', 'object-position', 'offset-.*', 'opacity', 'order', 'orphans', 'outline', 'outline-.*', 'overflow', 'overflow-.*', 'padding', 'padding-.*', 'page-break-.*', 'perspective', 'perspective-origin', 'pointer-events', 'position', 'quotes', 'resize', 'right', 'scroll-.*', 'shape-.*', 'tab-size', 'table-layout', 'text-.*', 'top', 'touch-action', 'transform', 'transform-.*', 'transition', 'transition-.*', 'unicode-bidi', 'unset', 'vertical-align', 'visibility', 'white-space', 'widows', 'width', 'will-change', 'word-.*', 'writing-mode', 'z-index'];

var dStyle = {
	query: `<.+ {prefix}(style-.+|${standardStyles.join('|')})>`,
	initialize(el, tag, attr) {
		this.property = attr.match[0].replace(/^style-/, '');
	},
	update(scope, el, tag, attr) {
		let value = attr.value();
		if (value !== this.value) {
			el.style[this.property] = this.value = value;
		}
	}
};

/*
`z-model` - Bind input
@ORDER 8

Creates a two way binding with input element value. The input value will be
set to the value of z-model. When the input value is changed by the user, the
data will also change, and the view will be kept up to date.

@CODE
<input type="text" z-model="blah">
{{ blah }} <!-- this will always display the value entered in the text input -->
<input type="button" z-click="thing()">
<script>
	const view = zam(document.body);
	view.blah = 'foo'; // will set the value of the input to blah
	view.thing = () => {
		console.log(view.blah); // will print whatever the user entered into the input
	}
</script>
@RESULT
*/
var dModel = {
	query: '<input|select|textarea {prefix}model>',
	block: true,
	order: 3, // must happen before z-attr-* binds with z-value on radio inputs
	create(scope, el, tag, attr) {
		let inputType = (el.getAttribute('type') || '').toLowerCase();
		this.type = inputType === 'checkbox' ? 'checkbox' : tag.name.toLowerCase() === 'select' ? 'select' : inputType === 'radio' ? 'radio' : ['range', 'number'].includes(inputType) ? 'number' : ['date', 'datetime-local', 'time', 'month', 'week'].includes(inputType) ? 'date' : 'text';
		if (this.type === 'radio' && !el.getAttribute('name')) {
			el.setAttribute('name', hash(scope.$id + JSON.stringify(attr.ast))); // group radios by their model and scope
		}
		this.getValue = option => {
			var valExpr = option.getAttribute(config.prefix + 'value');
			return valExpr ? evaluate(parse(valExpr), scope).value : option.getAttribute('value');
		};
		this.handler = () => {
			if (this.type === 'radio' && !el.checked) {
				return;
			}
			let value = this.type === 'checkbox' ? !!el.checked : this.type === 'select' ? this.getValue(el.options[el.selectedIndex]) : this.type === 'radio' ? this.getValue(el) : this.type === 'number' ? Number(el.value) : this.type === 'date' ? el.valueAsDate : el.value;
			if (value !== this.value) {
				this.value = value;
				evaluate({ // evaluate "<expression> = <value>"
					type: 'AssignmentExpression',
					operator: '=',
					left: attr.ast,
					right: { type: 'Literal', value }
				}, scope);
				scope.$();
			}
		};
		el.addEventListener('input', this.handler);
		el.addEventListener('change', this.handler);
		if (this.type === 'select') {
			el.selectedIndex = -1; // select empty value
		}
	},
	update(scope, el, tag, attr) {
		// update dom
		let value = attr.value();
		if (value !== this.value) {
			if (this.type === 'checkbox') {
				el.checked = !!value;
			} else if (this.type === 'select') {
				el.selectedIndex = Array.from(el.options).reduce((selected, option, i) => {
					let v = this.getValue(option);
					option.setAttribute('value', stringify(v));
					return v === value ? i : selected;
				}, -1);
			} else if (this.type === 'radio') {
				let v = this.getValue(el);
				el.setAttribute('value', stringify(v));
				el.checked = value === v;
			} else if (this.type === 'number') {
				el.value = Number(value);
			} else if (this.type === 'date') {
				el.valueAsDate = new Date(value.getTime()); // proxied date's will not work
			} else {
				el.value = stringify(value);
			}
			this.value = value;
		}
	},
	destroy(scope, el) {
		el.removeEventListener('input', this.handler);
		el.removeEventListener('change', this.handler);
	}
};

/*
`z-*-in` - Iterate through an array
@ORDER 4

Renders the element for each item in an array or object. Each value in the
array/object is assigned to a variable name specified in the attribute name
(see example below). 

@CODE
<div z-memo-in="memos">{{ $index }}: {{ memo }}</div><!-- $index is the index number of the element in the array -->
<em z-todo-in="todos">{{ todo.message }}</em>
<p z-item-in="basket" z-key="item.id">{{ item.name }}</p><!-- use `z-key` to specify a key for identifying each item in the array -->
<ul>
	<li z-info-in="apple">{{ $index }}: {{ info }}</li><!-- $index is the property name of the object -->
</ul>
<script>
	const view = zam(document.body);
	view.memos = ['food', 'code', 'clothes'];
	view.todos = [
		{ message: 'Buy food' },
		{ message: 'Fix code' },
		{ message: 'Wash clothes' }
	];
	view.basket = [
		{ id: 1, name: 'Chair' },
		{ id: 2, name: 'Table' },
		{ id: 2, name: 'Table' } // this won't show because the item above has the same id
	];
	view.apple = { type: 'granny smith', color: 'green' };
</script>
@RESULT

If `z-key` is not specified, `JSON.stringify` is used.

Note: This directive occurs before anything else.
*/
var dIn = {
	query: '<.+ {prefix}(.+)-in>',
	order: 2,
	block: true, // do not continue traversing through this dom element (separate zam will be created)
	initialize(el, tag, attr) {
		// dom manipulation shouldn't happen in init as it will interfere with the virtualdom
		this.items = [];
		const zKey = el.getAttribute(config.prefix + 'key');
		if (zKey) {
			const keyAST = parse(zKey);
			el.removeAttribute(config.prefix + 'key');
			this.key = data => evaluate(keyAST, { [attr.match[0]]: data }).value;
		} else {
			this.key = data => JSON.stringify(data);
		}
		this.template = createVNode(el.cloneNode(true));
	},
	create(scope, el, tag, attr) {
		this.marker = document.createComment(attr.name);
		el.parentNode.replaceChild(this.marker, el);
	},
	update(scope, el, tag, attr) {
		let value = attr.value() || [],
		    data = Object.keys(value).map(k => ({ index: k, computed: this.key(value[k]), datum: value[k] }));

		// recompute keys of existing nodes and remove old nodes
		[].concat(this.items).forEach(item => {
			item.key = this.key(item.datum);
			let kept = data.find(k => k.computed === item.key);
			if (!kept) {
				this.marker.parentNode.removeChild(item.node);
				item.view.$destroy();
				arrayRemove(this.items, item);
			}
		});
		// create new nodes and update existing nodes
		data.forEach(k => {
			let item = this.items.find(item_ => k.computed === item_.key);
			if (!item) {
				let vnode = this.template.clone();
				item = { key: k.computed, datum: k.datum, node: vnode.node };
				this.marker.parentNode.insertBefore(item.node, this.marker);
				item.view = zam$1(vnode, { [attr.match[0]]: item.datum }, scope);
			} else {
				arrayRemove(this.items, item);
				this.marker.parentNode.insertBefore(item.node, this.marker);
			}
			item.view.$index = k.index;
			item.view.$();
			this.items.push(item);
		});
	}
};

/*
`z-on-*` - Event handler
@ORDER 9

Executes an expression when the specified event happens. Event data is
available in `$event`. As a shorthand, `on-` may be omitted for standard DOM
events, such as `click`, `mousemove`, and `mousedown`.

@CODE
<input type="button" z-on-click="doSomething($event)">
<input type="button" z-click="doSomething($event)"><!-- equivalent to above -->
<script>
	const view = zam(document.body);
	view.doSomething = e => {
		console.log('click!', e.clientX, e.clientY);
	}
</script>
@RESULT
*/
const standardEvents = ['load', 'error', 'focus', 'blur', 'click', 'dblclick', 'mouse.*', 'keyup', 'keydown', 'keypress', 'input', 'change', 'submit', 'reset', 'scroll', 'resize', 'drag.*', 'drop'];

var dOn = {
	query: `<.+ {prefix}(on-.+|${standardEvents.join('|')})>`,
	initialize(el, tag, attr) {
		this.event = attr.match[0].replace(/^on-/, '');
	},
	create(scope, el, tag, attr) {
		this.handler = e => {
			scope.$event = e;
			attr.value();
			scope.$(); // if an assignment happens, this is necessary to trigger watchers
			delete scope.$event;
			if (this.event === 'submit') {
				e.preventDefault();
			}
		};
		el.addEventListener(this.event, this.handler);
	},
	destroy(scope, el) {
		el.removeEventListener(this.event, this.handler);
	}
};

/*
`z-skip` - Skip compilation of this element
@ORDER 10

Stops Zam from parsing content within the element.

@CODE
<div z-skip>
	{{ this will appear as it is (including curly braces) }}
	<div z-font-size="'12pt'">Directives will not be parsed</div>
</div>
<script>
	zam(document.body);
</script>
@RESULT
*/
var dSkip = {
	query: '<.+ {prefix}skip>',
	order: 1,
	block: true
};

/*
`z-cloak` - Hide content until zam has initiated
@ORDER 1

Prevents template tags from being visible before zam has initiated. A css rule
for `[z-clock]` should be added to set `display: none`.

@CODE
<style>
	[z-cloak] { display: none; }
</style>
Hello. <div z-cloak>this div will not be visible until zam has initiated {{ me.name }}</div>
<script>
	const view = zam(document.body);
	view.me = { name: 'Bob' };
</script>
@RESULT
*/
var dCloak = {
	query: '<.+ {prefix}cloak>',
	initialize(el) {
		el.display = '';
	}
};

[dText, dShow, dAttr, dClass, dExist, dStyle, dModel, dIn, dOn, dSkip, dCloak].forEach(createDirective);

return zam$1;

})));
//# sourceMappingURL=zam.js.map
